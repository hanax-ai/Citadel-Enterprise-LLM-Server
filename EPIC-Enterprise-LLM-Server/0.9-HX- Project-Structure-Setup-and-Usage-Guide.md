# HXP-Enterprise LLM Server - Project Structure Setup and Usage Guide

**Document Version:** 1.0  
**Date:** 2025-01-19  
**Project:** Citadel AI Operating System - HXP-Enterprise LLM Server  
**Target Server:** hx-llm-server-01 (192.168.10.27)  
**Purpose:** Complete guide for setting up and using the project structure on the target server  
**Scope:** Project initialization, configuration, and operational procedures  

---

## 📋 **DOCUMENT OVERVIEW**

### **Purpose and Scope**
This document provides comprehensive instructions for establishing the HXP-Enterprise LLM Server project structure on the target server (192.168.10.29). It covers the complete setup process from initial server preparation through operational usage, ensuring consistent deployment and management across all LLM server implementations.

### **Target Audience**
- **Infrastructure Engineers** responsible for server setup and configuration
- **DevOps Engineers** managing deployment and operational procedures
- **Development Teams** implementing AI model services and features
- **Operations Teams** responsible for ongoing maintenance and monitoring

### **Prerequisites**
- **Server Access:** Administrative access to hx-llm-server-01 (192.168.10.29)
- **Network Connectivity:** Confirmed connectivity to external services (SQL DB, Vector DB, Metrics Server)
- **Documentation Access:** Access to all MVP feature documents and architecture specifications
- **Security Clearance:** Appropriate permissions for development environment operations

---

## 🚀 **INITIAL SERVER PREPARATION**

### **System Requirements Validation**
Before beginning project structure setup, validate that the target server meets all requirements specified in the architecture document.

#### **Hardware Validation**
```bash
# Verify CPU specifications
lscpu | grep -E "CPU\(s\)|Model name|Thread\(s\) per core"
# Expected: AMD Ryzen Threadripper PRO 7965WX, 16+ CPU cores

# Verify memory specifications
free -h
# Expected: 256GB DDR5 ECC total memory available

# Verify storage specifications
df -h
lsblk
# Expected: /mnt/nvme0n1 (3.6TB NVMe) and /mnt/sda (7.3TB archive storage)

# Verify storage mounts
mount | grep -E "(nvme0n1|sda)"
# Expected: Both storage devices properly mounted

# Verify GPU specifications
nvidia-smi
# Expected: Dual NVIDIA RTX 5060 Ti (16 GB VRAM each)

# Verify NVIDIA driver version
nvidia-smi | grep "Driver Version"
# Expected: NVIDIA driver version 575-open or compatible
```

#### **Operating System Validation**
```bash
# Verify Ubuntu version
lsb_release -a
# Expected: Ubuntu 24.04 LTS or compatible version

# Verify system updates
sudo apt update && sudo apt list --upgradable
# Expected: System should be up-to-date or ready for updates

# Verify network connectivity
ping -c 3 192.168.10.35  # SQL Database Server
ping -c 3 192.168.10.30  # Vector Database Server
ping -c 3 192.168.10.37  # Metrics Server
ping -c 3 192.168.10.38  # Web Server
# Expected: Successful connectivity to all external services

# Verify hostname configuration
hostname
# Expected: hx-llm-server-01
```
```

### **User and Group Setup**
Establish the proper user and group structure for secure project management.

#### **Create Project User and Group**
```bash
# Create citadel group
sudo groupadd citadel

# Create citadel user (as per actual configuration)
sudo useradd -m -g citadel -s /bin/bash citadel

# Add citadel to necessary groups
sudo usermod -aG sudo,citadel citadel

# Note: Using 'citadel' user instead of 'agent0' to match actual server configuration
```

# Set up SSH access for citadel user (if needed)
sudo mkdir -p /home/citadel/.ssh
sudo chown citadel:citadel /home/citadel/.ssh
sudo chmod 700 /home/citadel/.ssh

# Verify user setup
id citadel
groups citadel
# Expected: citadel should be member of citadel and sudo groups
```
```

#### **Configure User Environment**
```bash
# Switch to citadel user
sudo su - citadel

# Set up basic environment
echo 'export CITADEL_HOME=/opt/citadel' >> ~/.bashrc
echo 'export CITADEL_ENV=development' >> ~/.bashrc
echo 'export PATH=$CITADEL_HOME/bin:$PATH' >> ~/.bashrc

# Source the environment
source ~/.bashrc

# Verify environment setup
echo $CITADEL_HOME
echo $CITADEL_ENV
# Expected: Environment variables should be properly set
```

---

## 🏗️ **PROJECT STRUCTURE INITIALIZATION**

### **Base Directory Creation**
Create the foundational directory structure that will house all project components.

#### **Primary Structure Setup**
```bash
# Create base project directory
sudo mkdir -p /opt/citadel

# Set ownership and permissions
sudo chown -R citadel:citadel /opt/citadel
sudo chmod -R 755 /opt/citadel

# Create primary subdirectories
cd /opt/citadel
mkdir -p {architecture,infrastructure,frameworks,operations,config,validation}

# Verify base structure
ls -la /opt/citadel
# Expected: Six primary directories with proper ownership and permissions
```

#### **Documentation Integration Setup**
```bash
# Create documentation reference structure
mkdir -p /opt/citadel/documentation/{prd,architecture,features,test-plans,templates}

# Create symbolic links to documentation (if documentation is centrally managed)
# Note: Adjust paths based on actual documentation location
ln -s /path/to/documentation/0.1-HX-Enterprise-Server-Product-Document.md \
      /opt/citadel/documentation/prd/

ln -s /path/to/documentation/0.2-HX-Enterprise-Server-Architecture.md \
      /opt/citadel/documentation/architecture/

# Create local documentation copies (alternative approach)
cp /path/to/documentation/*.md /opt/citadel/documentation/

# Verify documentation integration
ls -la /opt/citadel/documentation/
# Expected: All documentation files accessible within project structure
```

### **Configuration Management Setup**
Establish the configuration management framework that will support all MVP phases.

#### **Configuration Directory Structure**
```bash
# Create configuration subdirectories
cd /opt/citadel/config
mkdir -p {global,services,features,environments,secrets}

# Create secrets directory (matching actual configuration)
mkdir -p /opt/citadel/secrets
chmod 700 /opt/citadel/secrets

# Create environment-specific configurations
mkdir -p environments/{development,testing,staging,production}

# Create service-specific configurations
mkdir -p services/{ai-models,api-gateway,monitoring,integration}

# Create feature-specific configurations
mkdir -p features/{mvp1,mvp2,mvp3}

# Set appropriate permissions
chmod -R 750 /opt/citadel/config
chmod -R 700 /opt/citadel/config/secrets
chmod -R 700 /opt/citadel/secrets

# Verify configuration structure
tree /opt/citadel/config
# Expected: Hierarchical configuration structure with proper permissions
```

#### **Global Configuration Templates**
```bash
# Create global configuration template
cat > /opt/citadel/config/global/citadel.yaml << 'EOF'
# Citadel AI Operating System - Global Configuration
project:
  name: "HXP-Enterprise-LLM-Server"
  version: "1.0.0"
  environment: "development"
  server:
    hostname: "hx-llm-server-01"
    ip_address: "192.168.10.29"

external_services:
  sql_database:
    host: "192.168.10.35"
    port: 5433
    database: "citadel_ai"
    user: "citadel_admin"
  
  vector_database:
    host: "192.168.10.30"
    port: 8000
    service: "qdrant"
  
  metrics_server:
    host: "192.168.10.37"
    prometheus_port: 9090
    grafana_port: 3000
    alertmanager_port: 9093
  
  web_server:
    host: "192.168.10.38"
    port: 80
    service: "openui"

logging:
  level: "INFO"
  format: "json"
  rotation: "daily"
  retention_days: 30

monitoring:
  enabled: true
  metrics_collection: true
  health_checks: true
  performance_tracking: true
EOF

# Verify global configuration
cat /opt/citadel/config/global/citadel.yaml
# Expected: Complete global configuration template
```

---

## 🔧 **ENVIRONMENT SETUP AND CONFIGURATION**

### **Python Environment Setup**
Establish the Python environment that will support all AI model services and application components.

#### **Python Installation and Virtual Environment**
```bash
# Install Python 3.12 and dependencies
sudo apt update
sudo apt install -y python3.12 python3.12-venv python3.12-dev python3-pip

# Verify Python version matches actual configuration
python3.12 --version
# Expected: Python 3.12.3

# Create Python virtual environment
cd /opt/citadel
python3.12 -m venv env

# Activate virtual environment
source env/bin/activate

# Upgrade pip and install essential packages
pip install --upgrade pip setuptools wheel

# Install core dependencies
pip install \
    fastapi==0.104.1 \
    uvicorn==0.24.0 \
    pydantic==2.5.0 \
    asyncio-mqtt==0.13.0 \
    prometheus-client==0.19.0 \
    psycopg==3.1.13 \
    redis==5.0.1 \
    httpx==0.25.2 \
    pytest==7.4.3 \
    pytest-asyncio==0.21.1 \
    pytest-cov==4.1.0

# Install vLLM and AI model dependencies (matching actual configuration)
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu129
pip install vllm transformers accelerate
pip install fastapi uvicorn pyyaml psutil rich

# Create requirements file
pip freeze > /opt/citadel/requirements.txt

# Verify Python environment
python --version
pip list
# Expected: Python 3.12.x with all required packages installed

# Verify vLLM installation
python -c "import vllm; print(f'vLLM version: {vllm.__version__}')"
python -c "import torch; print(f'PyTorch version: {torch.__version__}')"
python -c "import transformers; print(f'Transformers version: {transformers.__version__}')"

# Verify CUDA availability
python -c "import torch; print(f'CUDA available: {torch.cuda.is_available()}')"
python -c "import torch; print(f'CUDA device count: {torch.cuda.device_count()}')"
# Expected: All AI model dependencies installed successfully, CUDA available with 2 devices
```

#### **Environment Activation Script**
```bash
# Create environment activation script
cat > /opt/citadel/bin/activate-citadel << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Environment Activation Script

# Set environment variables
export CITADEL_HOME=/opt/citadel
export CITADEL_ENV=development
export PYTHONPATH=$CITADEL_HOME/src:$PYTHONPATH
export PATH=$CITADEL_HOME/bin:$PATH

# Activate Python virtual environment
source $CITADEL_HOME/env/bin/activate

# Load configuration
if [ -f "$CITADEL_HOME/config/global/citadel.yaml" ]; then
    echo "Citadel environment activated successfully"
    echo "Project: HXP-Enterprise-LLM-Server"
    echo "Environment: $CITADEL_ENV"
    echo "Python: $(python --version)"
else
    echo "Warning: Global configuration not found"
fi
EOF

# Make script executable
chmod +x /opt/citadel/bin/activate-citadel

# Test environment activation
/opt/citadel/bin/activate-citadel
# Expected: Successful environment activation with confirmation messages
```

### **Service Framework Setup**
Establish the service framework that will support AI model deployment and management.

#### **Service Directory Structure**
```bash
# Create service framework directories
cd /opt/citadel
mkdir -p src/citadel_llm/{services,schemas,utilities,testing}

# Create AI model service directories
mkdir -p src/citadel_llm/services/ai_models/{mixtral,hermes,openchat,phi3}

# Create model storage directories (matching actual configuration)
mkdir -p /mnt/nvme0n1/models/{imp-v1-3b,Nous-Hermes-2-Mixtral-8x7B-DPO,phi-3-mini-4k-instruct,Qwen-Coder-DeepSeek-R1-14B}
mkdir -p /mnt/sda/logs/llm/{vllm,inference,gpu-metrics}
mkdir -p /opt/citadel/models/cache
mkdir -p /opt/citadel/models/configs

# Create infrastructure service directories
mkdir -p src/citadel_llm/services/infrastructure/{api_gateway,monitoring,integration}

# Create schema directories
mkdir -p src/citadel_llm/schemas/{configuration,requests,responses,validation}

# Create utility directories
mkdir -p src/citadel_llm/utilities/{logging,metrics,health_checks,data_processing}

# Create testing directories
mkdir -p src/citadel_llm/testing/{unit,integration,performance,security}

# Verify service structure
tree src/citadel_llm -d
# Expected: Complete service framework directory structure
```

#### **Base Service Templates**
```bash
# Create base service template
cat > /opt/citadel/src/citadel_llm/services/base_service.py << 'EOF'
"""
Citadel AI Operating System - Base Service Template
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
import asyncio
import logging
from datetime import datetime

class BaseService(ABC):
    """
    Abstract base class for all Citadel services
    
    Provides common functionality for service lifecycle management,
    health checking, metrics collection, and error handling.
    """
    
    def __init__(self, service_name: str, config: Dict[str, Any]):
        self.service_name = service_name
        self.config = config
        self.logger = logging.getLogger(f"citadel.{service_name}")
        self.start_time = None
        self.is_healthy = False
        self.metrics = {}
    
    async def initialize(self) -> bool:
        """Initialize the service"""
        try:
            self.logger.info(f"Initializing {self.service_name} service")
            await self._initialize_service()
            self.start_time = datetime.now()
            self.is_healthy = True
            self.logger.info(f"{self.service_name} service initialized successfully")
            return True
        except Exception as e:
            self.logger.error(f"Failed to initialize {self.service_name}: {e}")
            return False
    
    async def shutdown(self) -> bool:
        """Shutdown the service gracefully"""
        try:
            self.logger.info(f"Shutting down {self.service_name} service")
            await self._shutdown_service()
            self.is_healthy = False
            self.logger.info(f"{self.service_name} service shutdown completed")
            return True
        except Exception as e:
            self.logger.error(f"Error during {self.service_name} shutdown: {e}")
            return False
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform health check"""
        try:
            service_health = await self._health_check()
            return {
                "service": self.service_name,
                "healthy": self.is_healthy and service_health,
                "uptime_seconds": (datetime.now() - self.start_time).total_seconds() if self.start_time else 0,
                "metrics": self.metrics
            }
        except Exception as e:
            self.logger.error(f"Health check failed for {self.service_name}: {e}")
            return {
                "service": self.service_name,
                "healthy": False,
                "error": str(e)
            }
    
    @abstractmethod
    async def _initialize_service(self):
        """Service-specific initialization logic"""
        pass
    
    @abstractmethod
    async def _shutdown_service(self):
        """Service-specific shutdown logic"""
        pass
    
    @abstractmethod
    async def _health_check(self) -> bool:
        """Service-specific health check logic"""
        pass
EOF

# Verify base service template
python -c "import sys; sys.path.append('/opt/citadel/src'); from citadel_llm.services.base_service import BaseService; print('Base service template created successfully')"
# Expected: Successful import and confirmation message

#### **vLLM Service Template**
```bash
# Create vLLM service template
cat > /opt/citadel/src/citadel_llm/services/vllm_service.py << 'EOF'
"""
Citadel AI Operating System - vLLM Service Template
"""

from vllm import LLM, SamplingParams
from transformers import AutoTokenizer
import asyncio
import logging
from typing import Dict, Any, Optional
from .base_service import BaseService

class VLLMService(BaseService):
    """
    Base vLLM service implementation for AI models
    
    Provides common vLLM functionality for model loading,
    inference, and management across all AI model services.
    """
    
    def __init__(self, model_name: str, port: int, config: Dict[str, Any]):
        super().__init__(f"vllm-{model_name}", config)
        self.model_name = model_name
        self.port = port
        self.llm = None
        self.tokenizer = None
        self.sampling_params = SamplingParams(
            temperature=0.7,
            max_tokens=512,
            top_p=0.9
        )
    
    async def _initialize_service(self):
        """Initialize vLLM model and tokenizer"""
        try:
            self.logger.info(f"Loading vLLM model: {self.model_name}")
            
            # Initialize vLLM model
            self.llm = LLM(
                model=self.model_name,
                trust_remote_code=True,
                max_model_len=4096,
                gpu_memory_utilization=0.9
            )
            
            # Initialize tokenizer
            self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)
            
            self.logger.info(f"vLLM model {self.model_name} loaded successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to load vLLM model {self.model_name}: {e}")
            raise
    
    async def _shutdown_service(self):
        """Shutdown vLLM model"""
        try:
            if self.llm:
                del self.llm
                self.llm = None
            if self.tokenizer:
                del self.tokenizer
                self.tokenizer = None
            self.logger.info(f"vLLM model {self.model_name} shutdown completed")
        except Exception as e:
            self.logger.error(f"Error during vLLM model shutdown: {e}")
    
    async def _health_check(self) -> bool:
        """Check vLLM model health"""
        try:
            if not self.llm or not self.tokenizer:
                return False
            
            # Simple health check with a test prompt
            test_prompt = "Hello, how are you?"
            outputs = self.llm.generate([test_prompt], self.sampling_params)
            
            return len(outputs) > 0 and len(outputs[0].outputs) > 0
        except Exception as e:
            self.logger.error(f"vLLM health check failed: {e}")
            return False
    
    async def generate_response(self, prompt: str, **kwargs) -> Optional[str]:
        """Generate response using vLLM model"""
        try:
            # Update sampling parameters if provided
            if kwargs:
                sampling_params = SamplingParams(**kwargs)
            else:
                sampling_params = self.sampling_params
            
            # Generate response
            outputs = self.llm.generate([prompt], sampling_params)
            
            if outputs and len(outputs) > 0 and len(outputs[0].outputs) > 0:
                return outputs[0].outputs[0].text
            else:
                return None
                
        except Exception as e:
            self.logger.error(f"vLLM generation failed: {e}")
            return None
    
    def get_model_info(self) -> Dict[str, Any]:
        """Get model information"""
        return {
            "model_name": self.model_name,
            "port": self.port,
            "max_model_len": self.llm.llm_engine.model_config.max_model_len if self.llm else None,
            "gpu_memory_utilization": self.llm.llm_engine.model_config.gpu_memory_utilization if self.llm else None
        }
EOF

# Verify vLLM service template
python -c "import sys; sys.path.append('/opt/citadel/src'); from citadel_llm.services.vllm_service import VLLMService; print('vLLM service template created successfully')"
# Expected: Successful import and confirmation message
```

---

## 🚀 **FASTAPI API GATEWAY SETUP**

### **Basic API Gateway Implementation**
Establish the foundational FastAPI API gateway that will serve as the unified entry point for all AI model services.

#### **API Gateway Application Setup**
```bash
# Create API gateway application
cat > /opt/citadel/src/citadel_llm/api_gateway/main.py << 'EOF'
"""
Citadel AI Operating System - FastAPI API Gateway
"""

from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import uvicorn
import logging
from typing import Dict, Any, Optional
import httpx
import asyncio
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("citadel.api_gateway")

# Create FastAPI application
app = FastAPI(
    title="HXP-Enterprise LLM Server API Gateway",
    description="Unified API Gateway for AI Model Services",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Model service configuration
MODEL_SERVICES = {
    "mixtral": {"url": "http://localhost:11400", "name": "Mixtral-8x7B"},
    "hermes": {"url": "http://localhost:11401", "name": "Hermes-2"},
    "openchat": {"url": "http://localhost:11402", "name": "OpenChat-3.5"},
    "phi3": {"url": "http://localhost:11403", "name": "Phi-3-Mini"}
}

@app.on_event("startup")
async def startup_event():
    """Application startup event"""
    logger.info("API Gateway starting up...")
    logger.info(f"Configured model services: {list(MODEL_SERVICES.keys())}")

@app.on_event("shutdown")
async def shutdown_event():
    """Application shutdown event"""
    logger.info("API Gateway shutting down...")

@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "service": "HXP-Enterprise LLM Server API Gateway",
        "version": "1.0.0",
        "status": "operational",
        "timestamp": datetime.utcnow().isoformat(),
        "available_models": list(MODEL_SERVICES.keys())
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    health_status = {
        "service": "api_gateway",
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "model_services": {}
    }
    
    # Check each model service health
    async with httpx.AsyncClient() as client:
        for model_name, config in MODEL_SERVICES.items():
            try:
                response = await client.get(f"{config['url']}/health", timeout=5.0)
                health_status["model_services"][model_name] = {
                    "status": "healthy" if response.status_code == 200 else "unhealthy",
                    "url": config["url"]
                }
            except Exception as e:
                health_status["model_services"][model_name] = {
                    "status": "unreachable",
                    "url": config["url"],
                    "error": str(e)
                }
    
    return health_status

@app.post("/v1/chat/completions")
async def chat_completions(request: Dict[str, Any]):
    """OpenAI-compatible chat completions endpoint"""
    try:
        # Extract model from request
        model = request.get("model", "mixtral")
        if model not in MODEL_SERVICES:
            raise HTTPException(
                status_code=400,
                detail=f"Model {model} not available. Available models: {list(MODEL_SERVICES.keys())}"
            )
        
        # Extract messages from request
        messages = request.get("messages", [])
        if not messages:
            raise HTTPException(
                status_code=400,
                detail="No messages provided"
            )
        
        # Convert messages to prompt (basic implementation)
        prompt = ""
        for message in messages:
            role = message.get("role", "user")
            content = message.get("content", "")
            if role == "user":
                prompt += f"User: {content}\n"
            elif role == "assistant":
                prompt += f"Assistant: {content}\n"
            elif role == "system":
                prompt += f"System: {content}\n"
        
        # Route request to appropriate model service
        model_config = MODEL_SERVICES[model]
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{model_config['url']}/generate",
                json={"prompt": prompt, "max_tokens": request.get("max_tokens", 512)},
                timeout=30.0
            )
            
            if response.status_code == 200:
                result = response.json()
                return {
                    "id": f"chatcmpl-{datetime.utcnow().timestamp()}",
                    "object": "chat.completion",
                    "created": int(datetime.utcnow().timestamp()),
                    "model": model,
                    "choices": [{
                        "index": 0,
                        "message": {
                            "role": "assistant",
                            "content": result.get("response", "")
                        },
                        "finish_reason": "stop"
                    }],
                    "usage": {
                        "prompt_tokens": len(prompt.split()),
                        "completion_tokens": len(result.get("response", "").split()),
                        "total_tokens": len(prompt.split()) + len(result.get("response", "").split())
                    }
                }
            else:
                raise HTTPException(
                    status_code=response.status_code,
                    detail=f"Model service error: {response.text}"
                )
                
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Chat completions error: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Internal server error: {str(e)}"
        )

@app.get("/models")
async def list_models():
    """List available models"""
    return {
        "object": "list",
        "data": [
            {
                "id": model_name,
                "object": "model",
                "created": int(datetime.utcnow().timestamp()),
                "owned_by": "citadel-ai"
            }
            for model_name in MODEL_SERVICES.keys()
        ]
    }

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=False,
        log_level="info"
    )
EOF

# Create API gateway configuration
cat > /opt/citadel/config/services/api_gateway.yaml << 'EOF'
# API Gateway Configuration
api_gateway:
  host: "0.0.0.0"
  port: 8000
  reload: false
  log_level: "info"
  
  # Model service endpoints
  model_services:
    mixtral:
      url: "http://localhost:11400"
      name: "Mixtral-8x7B"
      description: "Large language model for complex reasoning"
    
    hermes:
      url: "http://localhost:11401"
      name: "Hermes-2"
      description: "Conversational AI model"
    
    openchat:
      url: "http://localhost:11402"
      name: "OpenChat-3.5"
      description: "Open-source conversational model"
    
    phi3:
      url: "http://localhost:11403"
      name: "Phi-3-Mini"
      description: "Compact language model"
  
  # Basic rate limiting (requests per minute)
  rate_limit:
    enabled: true
    requests_per_minute: 100
  
  # CORS settings
  cors:
    allow_origins: ["*"]
    allow_credentials: true
    allow_methods: ["*"]
    allow_headers: ["*"]
EOF

# Verify API gateway setup
python -c "import sys; sys.path.append('/opt/citadel/src/citadel_llm/api_gateway'); from main import app; print('API Gateway setup successful')"
# Expected: Successful import and confirmation message
```

---

## 📊 **MONITORING AND LOGGING SETUP**

### **Logging Configuration**
Establish comprehensive logging that supports debugging, monitoring, and operational analysis.

#### **Logging Framework Setup**
```bash
# Create logging configuration
cat > /opt/citadel/config/global/logging.yaml << 'EOF'
# Citadel AI Operating System - Logging Configuration

version: 1
disable_existing_loggers: false

formatters:
  standard:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
  
  json:
    format: '{"timestamp": "%(asctime)s", "service": "%(name)s", "level": "%(levelname)s", "message": "%(message)s", "module": "%(module)s", "function": "%(funcName)s", "line": %(lineno)d}'
  
  detailed:
    format: '%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(funcName)s:%(lineno)d - %(message)s'

handlers:
  console:
    class: logging.StreamHandler
    level: INFO
    formatter: standard
    stream: ext://sys.stdout
  
  file:
    class: logging.handlers.RotatingFileHandler
    level: DEBUG
    formatter: json
    filename: /opt/citadel/logs/citadel.log
    maxBytes: 10485760  # 10MB
    backupCount: 10
  
  error_file:
    class: logging.handlers.RotatingFileHandler
    level: ERROR
    formatter: detailed
    filename: /opt/citadel/logs/citadel_errors.log
    maxBytes: 10485760  # 10MB
    backupCount: 5

loggers:
  citadel:
    level: DEBUG
    handlers: [console, file, error_file]
    propagate: false
  
  citadel.ai_models:
    level: DEBUG
    handlers: [console, file]
    propagate: false
  
  citadel.api_gateway:
    level: INFO
    handlers: [console, file]
    propagate: false

root:
  level: INFO
  handlers: [console, file]
EOF

# Create logs directory (matching actual configuration)
mkdir -p /mnt/sda/logs/llm/{vllm,inference,gpu-metrics}
mkdir -p /opt/citadel/logs
chmod 755 /opt/citadel/logs
chmod 755 /mnt/sda/logs/llm

# Create logging utility
cat > /opt/citadel/src/citadel_llm/utilities/logging_config.py << 'EOF'
"""
Citadel AI Operating System - Logging Configuration Utility
"""

import logging.config
import yaml
import os
from pathlib import Path

def setup_logging(config_path: str = None):
    """
    Setup logging configuration for Citadel services
    
    Args:
        config_path: Path to logging configuration file
    """
    if config_path is None:
        config_path = "/opt/citadel/config/global/logging.yaml"
    
    if os.path.exists(config_path):
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        
        # Ensure log directory exists
        log_dir = Path("/opt/citadel/logs")
        log_dir.mkdir(exist_ok=True)
        
        logging.config.dictConfig(config)
        logging.getLogger("citadel").info("Logging configuration loaded successfully")
    else:
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        logging.getLogger("citadel").warning(f"Logging config not found at {config_path}, using basic configuration")

def get_logger(name: str):
    """
    Get a logger instance for a specific component
    
    Args:
        name: Logger name (e.g., 'citadel.ai_models.mixtral')
    
    Returns:
        Logger instance
    """
    return logging.getLogger(name)
EOF

# Test logging setup
cd /opt/citadel
python -c "
import sys
sys.path.append('/opt/citadel/src')
from citadel_llm.utilities.logging_config import setup_logging, get_logger
setup_logging()
logger = get_logger('citadel.test')
logger.info('Logging setup test successful')
"
# Expected: Successful logging test with log file creation
```

### **Metrics Collection Setup**
Establish metrics collection that integrates with the operational Metrics Server.

#### **Metrics Framework Configuration**
```bash
# Create metrics configuration
cat > /opt/citadel/config/global/metrics.yaml << 'EOF'
# Citadel AI Operating System - Metrics Configuration

prometheus:
  enabled: true
  port: 9090
  metrics_path: "/metrics"
  scrape_interval: "15s"
  
  # Metrics Server integration
  remote_server:
    host: "192.168.10.37"
    port: 9090
    push_gateway_port: 9091

custom_metrics:
  ai_models:
    - name: "model_inference_duration_seconds"
      type: "histogram"
      description: "Time spent on model inference"
      buckets: [0.1, 0.5, 1.0, 2.0, 5.0, 10.0]
    
    - name: "model_requests_total"
      type: "counter"
      description: "Total number of model requests"
    
    - name: "model_active_connections"
      type: "gauge"
      description: "Number of active model connections"
  
  system:
    - name: "system_cpu_usage_percent"
      type: "gauge"
      description: "System CPU usage percentage"
    
    - name: "system_memory_usage_bytes"
      type: "gauge"
      description: "System memory usage in bytes"
    
    - name: "system_disk_usage_bytes"
      type: "gauge"
      description: "System disk usage in bytes"

collection:
  interval_seconds: 15
  batch_size: 100
  retention_days: 30
EOF

# Create metrics utility
cat > /opt/citadel/src/citadel_llm/utilities/metrics_collector.py << 'EOF'
"""
Citadel AI Operating System - Metrics Collection Utility
"""

from prometheus_client import Counter, Histogram, Gauge, CollectorRegistry, push_to_gateway
import time
import psutil
import asyncio
import logging
from typing import Dict, Any

class MetricsCollector:
    """
    Metrics collection and reporting for Citadel services
    """
    
    def __init__(self, service_name: str, push_gateway_host: str = "192.168.10.37", push_gateway_port: int = 9091):
        self.service_name = service_name
        self.push_gateway_host = push_gateway_host
        self.push_gateway_port = push_gateway_port
        self.registry = CollectorRegistry()
        self.logger = logging.getLogger(f"citadel.metrics.{service_name}")
        
        # Initialize metrics
        self._initialize_metrics()
    
    def _initialize_metrics(self):
        """Initialize Prometheus metrics"""
        # AI Model metrics
        self.model_inference_duration = Histogram(
            'model_inference_duration_seconds',
            'Time spent on model inference',
            ['model_name', 'service'],
            buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0],
            registry=self.registry
        )
        
        self.model_requests_total = Counter(
            'model_requests_total',
            'Total number of model requests',
            ['model_name', 'service', 'status'],
            registry=self.registry
        )
        
        self.model_active_connections = Gauge(
            'model_active_connections',
            'Number of active model connections',
            ['model_name', 'service'],
            registry=self.registry
        )
        
        # System metrics
        self.system_cpu_usage = Gauge(
            'system_cpu_usage_percent',
            'System CPU usage percentage',
            ['service'],
            registry=self.registry
        )
        
        self.system_memory_usage = Gauge(
            'system_memory_usage_bytes',
            'System memory usage in bytes',
            ['service'],
            registry=self.registry
        )
    
    def record_inference_time(self, model_name: str, duration: float):
        """Record model inference time"""
        self.model_inference_duration.labels(
            model_name=model_name,
            service=self.service_name
        ).observe(duration)
    
    def increment_request_count(self, model_name: str, status: str = "success"):
        """Increment request counter"""
        self.model_requests_total.labels(
            model_name=model_name,
            service=self.service_name,
            status=status
        ).inc()
    
    def update_active_connections(self, model_name: str, count: int):
        """Update active connections gauge"""
        self.model_active_connections.labels(
            model_name=model_name,
            service=self.service_name
        ).set(count)
    
    def collect_system_metrics(self):
        """Collect system metrics"""
        # CPU usage
        cpu_percent = psutil.cpu_percent(interval=1)
        self.system_cpu_usage.labels(service=self.service_name).set(cpu_percent)
        
        # Memory usage
        memory = psutil.virtual_memory()
        self.system_memory_usage.labels(service=self.service_name).set(memory.used)
    
    async def push_metrics(self):
        """Push metrics to Prometheus Push Gateway"""
        try:
            gateway_url = f"{self.push_gateway_host}:{self.push_gateway_port}"
            push_to_gateway(gateway_url, job=self.service_name, registry=self.registry)
            self.logger.debug(f"Metrics pushed successfully to {gateway_url}")
        except Exception as e:
            self.logger.error(f"Failed to push metrics: {e}")
    
    async def start_collection(self, interval_seconds: int = 15):
        """Start periodic metrics collection"""
        self.logger.info(f"Starting metrics collection with {interval_seconds}s interval")
        
        while True:
            try:
                self.collect_system_metrics()
                await self.push_metrics()
                await asyncio.sleep(interval_seconds)
            except Exception as e:
                self.logger.error(f"Error in metrics collection: {e}")
                await asyncio.sleep(interval_seconds)
EOF

# Test metrics setup
cd /opt/citadel
python -c "
import sys
sys.path.append('/opt/citadel/src')
from citadel_llm.utilities.metrics_collector import MetricsCollector
collector = MetricsCollector('test_service')
collector.collect_system_metrics()
print('Metrics collection setup successful')
"
# Expected: Successful metrics collection test

### **Enhanced Monitoring Framework**
Establish enhanced monitoring capabilities that integrate with the external Metrics Server.

#### **Prometheus Integration Setup**
```bash
# Create Prometheus configuration for external metrics server
cat > /opt/citadel/config/monitoring/prometheus.yml << 'EOF'
# Citadel AI Operating System - Prometheus Configuration

global:
  scrape_interval: 15s
  evaluation_interval: 15s

# External Metrics Server (192.168.10.37)
scrape_configs:
  # Scrape Citadel services
  - job_name: 'citadel-ai-models'
    static_configs:
      - targets: 
        - 'localhost:11400'  # Mixtral
        - 'localhost:11401'  # Hermes
        - 'localhost:11402'  # OpenChat
        - 'localhost:11403'  # Phi3
    metrics_path: '/metrics'
    scrape_interval: 15s

  # Scrape API Gateway
  - job_name: 'citadel-api-gateway'
    static_configs:
      - targets: ['localhost:8000']
    metrics_path: '/metrics'
    scrape_interval: 15s

  # Scrape system metrics
  - job_name: 'citadel-system'
    static_configs:
      - targets: ['localhost:9090']
    metrics_path: '/metrics'
    scrape_interval: 30s

# Alerting rules (basic)
rule_files:
  - 'alerts.yml'

# Alertmanager configuration
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - '192.168.10.37:9093'  # External Alertmanager
EOF

# Create basic alerting rules
cat > /opt/citadel/config/monitoring/alerts.yml << 'EOF'
# Citadel AI Operating System - Alerting Rules

groups:
  - name: citadel_alerts
    rules:
      # Service health alerts
      - alert: ServiceDown
        expr: up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Service {{ $labels.instance }} is down"
          description: "Service {{ $labels.instance }} has been down for more than 1 minute"

      # High CPU usage
      - alert: HighCPUUsage
        expr: system_cpu_usage_percent > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage on {{ $labels.instance }}"
          description: "CPU usage is above 80% for more than 5 minutes"

      # High memory usage
      - alert: HighMemoryUsage
        expr: system_memory_usage_bytes / system_memory_total_bytes > 0.9
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High memory usage on {{ $labels.instance }}"
          description: "Memory usage is above 90% for more than 5 minutes"

      # Model inference errors
      - alert: ModelInferenceErrors
        expr: rate(model_requests_total{status="error"}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High model inference error rate on {{ $labels.model_name }}"
          description: "Error rate is above 10% for more than 2 minutes"
EOF

# Create monitoring dashboard configuration
cat > /opt/citadel/config/monitoring/dashboards/citadel-overview.json << 'EOF'
{
  "dashboard": {
    "title": "Citadel AI Operating System - Overview",
    "panels": [
      {
        "title": "System Overview",
        "type": "stat",
        "targets": [
          {
            "expr": "up",
            "legendFormat": "{{job}}"
          }
        ]
      },
      {
        "title": "CPU Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "system_cpu_usage_percent",
            "legendFormat": "{{service}}"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "system_memory_usage_bytes / system_memory_total_bytes * 100",
            "legendFormat": "{{service}}"
          }
        ]
      },
      {
        "title": "Model Requests",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(model_requests_total[5m])",
            "legendFormat": "{{model_name}}"
          }
        ]
      },
      {
        "title": "Model Inference Duration",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(model_inference_duration_seconds_sum[5m]) / rate(model_inference_duration_seconds_count[5m])",
            "legendFormat": "{{model_name}}"
          }
        ]
      }
    ]
  }
}
EOF

# Create monitoring startup script
cat > /opt/citadel/bin/start-monitoring << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Monitoring Startup Script

echo "Starting Citadel monitoring services..."

# Start Prometheus (if running locally)
if [ -f "/opt/citadel/config/monitoring/prometheus.yml" ]; then
    echo "Starting Prometheus..."
    prometheus --config.file=/opt/citadel/config/monitoring/prometheus.yml &
    echo "Prometheus started on port 9090"
fi

# Start metrics collection for all services
echo "Starting metrics collection..."
cd /opt/citadel
source bin/activate-citadel

# Start metrics collection in background
python -c "
import asyncio
import sys
sys.path.append('/opt/citadel/src')
from citadel_llm.utilities.metrics_collector import MetricsCollector

async def start_collection():
    collectors = [
        MetricsCollector('mixtral'),
        MetricsCollector('hermes'),
        MetricsCollector('openchat'),
        MetricsCollector('phi3'),
        MetricsCollector('api_gateway')
    ]
    
    tasks = [collector.start_collection() for collector in collectors]
    await asyncio.gather(*tasks)

if __name__ == '__main__':
    asyncio.run(start_collection())
" &

echo "Monitoring services started successfully"
echo "Prometheus: http://localhost:9090"
echo "API Gateway: http://localhost:8000"
echo "Grafana: http://192.168.10.37:3000"
EOF

chmod +x /opt/citadel/bin/start-monitoring

# Test monitoring setup
/opt/citadel/bin/start-monitoring
# Expected: Monitoring services started successfully

# Create GPU monitoring script (matching actual configuration)
cat > /opt/citadel/bin/gpu_monitor.sh << 'EOF'
#!/bin/bash
# GPU Temperature and Memory Logger (matching actual configuration)

echo "$(date): GPU Status Report" >> /mnt/sda/logs/llm/gpu-metrics/gpu.log
nvidia-smi --query-gpu=timestamp,name,temperature.gpu,memory.used,memory.total,utilization.gpu --format=csv,noheader,nounits >> /mnt/sda/logs/llm/gpu-metrics/gpu.log
echo "---" >> /mnt/sda/logs/llm/gpu-metrics/gpu.log
EOF

chmod +x /opt/citadel/bin/gpu_monitor.sh

# Add GPU monitoring to crontab (matching actual configuration)
(crontab -l 2>/dev/null; echo "*/5 * * * * /opt/citadel/bin/gpu_monitor.sh") | crontab -
```

---

## 🔧 **SYSTEMD SERVICE INTEGRATION**

### **Systemd Service Templates**
Establish systemd service templates for managing all Citadel services with proper lifecycle management.

#### **Base Systemd Service Template**
```bash
# Create systemd service directory
sudo mkdir -p /etc/systemd/system/citadel

# Create base systemd service template
cat > /opt/citadel/config/systemd/citadel-service@.service << 'EOF'
[Unit]
Description=Citadel AI Service - %i
After=network.target
Wants=network.target

[Service]
Type=simple
User=citadel
Group=citadel
WorkingDirectory=/opt/citadel
Environment=CITADEL_HOME=/opt/citadel
Environment=CITADEL_ENV=production
Environment=PYTHONPATH=/opt/citadel/src
ExecStartPre=/opt/citadel/bin/activate-citadel
ExecStart=/opt/citadel/env/bin/python /opt/citadel/src/citadel_llm/services/%i/main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10
TimeoutStartSec=300
TimeoutStopSec=60

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/citadel/logs /mnt/sda/logs/llm /mnt/nvme0n1/models

[Install]
WantedBy=multi-user.target
EOF

# Create specific service files for each AI model
cat > /opt/citadel/config/systemd/citadel-mixtral.service << 'EOF'
[Unit]
Description=Citadel AI - Mixtral-8x7B Service
After=network.target
Wants=network.target

[Service]
Type=simple
User=citadel
Group=citadel
WorkingDirectory=/opt/citadel
Environment=CITADEL_HOME=/opt/citadel
Environment=CITADEL_ENV=production
Environment=PYTHONPATH=/opt/citadel/src
Environment=MODEL_NAME=/mnt/nvme0n1/models/Nous-Hermes-2-Mixtral-8x7B-DPO
Environment=SERVICE_PORT=11400
ExecStartPre=/opt/citadel/bin/activate-citadel
ExecStart=/opt/citadel/env/bin/python /opt/citadel/src/citadel_llm/services/ai_models/mixtral/main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=30
TimeoutStartSec=600
TimeoutStopSec=120

# Resource limits for large model
LimitNOFILE=65536
LimitNPROC=4096
LimitMEMLOCK=infinity

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/citadel/logs /opt/citadel/models

[Install]
WantedBy=multi-user.target
EOF

cat > /opt/citadel/config/systemd/citadel-hermes.service << 'EOF'
[Unit]
Description=Citadel AI - Hermes-2 Service
After=network.target
Wants=network.target

[Service]
Type=simple
User=agent0
Group=citadel
WorkingDirectory=/opt/citadel
Environment=CITADEL_HOME=/opt/citadel
Environment=CITADEL_ENV=production
Environment=PYTHONPATH=/opt/citadel/src
Environment=MODEL_NAME=/mnt/nvme0n1/models/imp-v1-3b
Environment=SERVICE_PORT=11401
ExecStartPre=/opt/citadel/bin/activate-citadel
ExecStart=/opt/citadel/env/bin/python /opt/citadel/src/citadel_llm/services/ai_models/hermes/main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=30
TimeoutStartSec=300
TimeoutStopSec=60

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/citadel/logs /opt/citadel/models

[Install]
WantedBy=multi-user.target
EOF

cat > /opt/citadel/config/systemd/citadel-openchat.service << 'EOF'
[Unit]
Description=Citadel AI - OpenChat-3.5 Service
After=network.target
Wants=network.target

[Service]
Type=simple
User=agent0
Group=citadel
WorkingDirectory=/opt/citadel
Environment=CITADEL_HOME=/opt/citadel
Environment=CITADEL_ENV=production
Environment=PYTHONPATH=/opt/citadel/src
Environment=MODEL_NAME=/mnt/nvme0n1/models/Qwen-Coder-DeepSeek-R1-14B
Environment=SERVICE_PORT=11402
ExecStartPre=/opt/citadel/bin/activate-citadel
ExecStart=/opt/citadel/env/bin/python /opt/citadel/src/citadel_llm/services/ai_models/openchat/main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=30
TimeoutStartSec=300
TimeoutStopSec=60

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/citadel/logs /opt/citadel/models

[Install]
WantedBy=multi-user.target
EOF

cat > /opt/citadel/config/systemd/citadel-phi3.service << 'EOF'
[Unit]
Description=Citadel AI - Phi-3-Mini Service
After=network.target
Wants=network.target

[Service]
Type=simple
User=agent0
Group=citadel
WorkingDirectory=/opt/citadel
Environment=CITADEL_HOME=/opt/citadel
Environment=CITADEL_ENV=production
Environment=PYTHONPATH=/opt/citadel/src
Environment=MODEL_NAME=/mnt/nvme0n1/models/phi-3-mini-4k-instruct
Environment=SERVICE_PORT=11403
ExecStartPre=/opt/citadel/bin/activate-citadel
ExecStart=/opt/citadel/env/bin/python /opt/citadel/src/citadel_llm/services/ai_models/phi3/main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=30
TimeoutStartSec=300
TimeoutStopSec=60

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/citadel/logs /opt/citadel/models

[Install]
WantedBy=multi-user.target
EOF

cat > /opt/citadel/config/systemd/citadel-api-gateway.service << 'EOF'
[Unit]
Description=Citadel AI - API Gateway Service
After=network.target citadel-mixtral.service citadel-hermes.service citadel-openchat.service citadel-phi3.service
Wants=network.target

[Service]
Type=simple
User=citadel
Group=citadel
WorkingDirectory=/opt/citadel
Environment=CITADEL_HOME=/opt/citadel
Environment=CITADEL_ENV=production
Environment=PYTHONPATH=/opt/citadel/src
ExecStartPre=/opt/citadel/bin/activate-citadel
ExecStart=/opt/citadel/env/bin/python /opt/citadel/src/citadel_llm/api_gateway/main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10
TimeoutStartSec=60
TimeoutStopSec=30

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/opt/citadel/logs /mnt/sda/logs/llm

[Install]
WantedBy=multi-user.target
EOF

#### **Systemd Service Management Scripts**
```bash
# Create systemd service management script
cat > /opt/citadel/bin/citadel-systemd << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Systemd Service Management

CITADEL_HOME="/opt/citadel"
SERVICE_NAME="$2"
ACTION="$1"

# Function to copy service files
copy_service_files() {
    echo "Installing Citadel systemd service files..."
    sudo cp $CITADEL_HOME/config/systemd/*.service /etc/systemd/system/
    sudo systemctl daemon-reload
    echo "Service files installed successfully"
}

# Function to enable services
enable_services() {
    echo "Enabling Citadel services..."
    sudo systemctl enable citadel-mixtral.service
    sudo systemctl enable citadel-hermes.service
    sudo systemctl enable citadel-openchat.service
    sudo systemctl enable citadel-phi3.service
    sudo systemctl enable citadel-api-gateway.service
    echo "Services enabled successfully"
}

case "$ACTION" in
    install)
        copy_service_files
        enable_services
        echo "Citadel systemd services installed and enabled"
        ;;
    start)
        if [ -z "$SERVICE_NAME" ]; then
            echo "Starting all Citadel services..."
            sudo systemctl start citadel-mixtral.service
            sudo systemctl start citadel-hermes.service
            sudo systemctl start citadel-openchat.service
            sudo systemctl start citadel-phi3.service
            sudo systemctl start citadel-api-gateway.service
        else
            echo "Starting Citadel service: $SERVICE_NAME"
            sudo systemctl start citadel-$SERVICE_NAME.service
        fi
        ;;
    stop)
        if [ -z "$SERVICE_NAME" ]; then
            echo "Stopping all Citadel services..."
            sudo systemctl stop citadel-api-gateway.service
            sudo systemctl stop citadel-phi3.service
            sudo systemctl stop citadel-openchat.service
            sudo systemctl stop citadel-hermes.service
            sudo systemctl stop citadel-mixtral.service
        else
            echo "Stopping Citadel service: $SERVICE_NAME"
            sudo systemctl stop citadel-$SERVICE_NAME.service
        fi
        ;;
    restart)
        if [ -z "$SERVICE_NAME" ]; then
            echo "Restarting all Citadel services..."
            $0 stop
            sleep 5
            $0 start
        else
            echo "Restarting Citadel service: $SERVICE_NAME"
            sudo systemctl restart citadel-$SERVICE_NAME.service
        fi
        ;;
    status)
        if [ -z "$SERVICE_NAME" ]; then
            echo "=== Citadel Services Status ==="
            sudo systemctl status citadel-mixtral.service --no-pager -l
            echo
            sudo systemctl status citadel-hermes.service --no-pager -l
            echo
            sudo systemctl status citadel-openchat.service --no-pager -l
            echo
            sudo systemctl status citadel-phi3.service --no-pager -l
            echo
            sudo systemctl status citadel-api-gateway.service --no-pager -l
        else
            echo "Status of Citadel service: $SERVICE_NAME"
            sudo systemctl status citadel-$SERVICE_NAME.service --no-pager -l
        fi
        ;;
    logs)
        if [ -z "$SERVICE_NAME" ]; then
            echo "Usage: $0 logs <service_name>"
            echo "Available services: mixtral, hermes, openchat, phi3, api-gateway"
        else
            echo "Logs for Citadel service: $SERVICE_NAME"
            sudo journalctl -u citadel-$SERVICE_NAME.service -f
        fi
        ;;
    *)
        echo "Usage: $0 {install|start|stop|restart|status|logs} [service_name]"
        echo "Available services: mixtral, hermes, openchat, phi3, api-gateway"
        echo "Examples:"
        echo "  $0 install                    # Install all service files"
        echo "  $0 start                      # Start all services"
        echo "  $0 start mixtral              # Start specific service"
        echo "  $0 status                     # Show all service status"
        echo "  $0 logs mixtral               # Show service logs"
        exit 1
        ;;
esac
EOF

chmod +x /opt/citadel/bin/citadel-systemd

# Install systemd services
/opt/citadel/bin/citadel-systemd install
# Expected: Service files installed and enabled successfully

# Create vLLM startup script (matching actual configuration)
cat > /opt/citadel/bin/start_vllm.sh << 'EOF'
#!/bin/bash
# vLLM Startup Script (matching actual configuration)

# Set CUDA environment
export CUDA_VISIBLE_DEVICES=0,1

# Start vLLM API server for Mixtral model
python3 -m vllm.entrypoints.api_server \
  --model /mnt/nvme0n1/models/Nous-Hermes-2-Mixtral-8x7B-DPO \
  --tokenizer /mnt/nvme0n1/models/Nous-Hermes-2-Mixtral-8x7B-DPO \
  --port 8001 \
  --host 0.0.0.0 \
  --max-num-batched-tokens 32768 \
  --max-model-len 32768 \
  --gpu-memory-utilization 0.90 \
  --swap-space 8
EOF

chmod +x /opt/citadel/bin/start_vllm.sh
```

---

## 🔄 **OPERATIONAL PROCEDURES**

### **Service Management Scripts**
Create operational scripts for managing the project lifecycle and services.

#### **Service Control Scripts**
```bash
# Create service management script
cat > /opt/citadel/bin/citadel-service << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Service Management Script

CITADEL_HOME="/opt/citadel"
SERVICE_NAME="$2"
ACTION="$1"

# Source environment
source $CITADEL_HOME/bin/activate-citadel

case "$ACTION" in
    start)
        echo "Starting Citadel service: $SERVICE_NAME"
        # Service-specific start logic will be implemented here
        ;;
    stop)
        echo "Stopping Citadel service: $SERVICE_NAME"
        # Service-specific stop logic will be implemented here
        ;;
    restart)
        echo "Restarting Citadel service: $SERVICE_NAME"
        $0 stop $SERVICE_NAME
        sleep 2
        $0 start $SERVICE_NAME
        ;;
    status)
        echo "Checking status of Citadel service: $SERVICE_NAME"
        # Service-specific status logic will be implemented here
        ;;
    health)
        echo "Performing health check for Citadel service: $SERVICE_NAME"
        # Service-specific health check logic will be implemented here
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|health} <service_name>"
        echo "Available services will be listed here once implemented"
        exit 1
        ;;
esac
EOF

# Make script executable
chmod +x /opt/citadel/bin/citadel-service

# Create system health check script
cat > /opt/citadel/bin/citadel-health << 'EOF'
#!/bin/bash
# Citadel AI Operating System - System Health Check Script

CITADEL_HOME="/opt/citadel"

echo "=== Citadel AI Operating System - Health Check ==="
echo "Timestamp: $(date)"
echo "Server: hx-llm-server-01 (192.168.10.29)"
echo

# Check system resources
echo "=== System Resources ==="
echo "CPU Usage: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%"
echo "Memory Usage: $(free | grep Mem | awk '{printf "%.1f%%", $3/$2 * 100.0}')"
echo "Disk Usage: $(df -h /opt/citadel | tail -1 | awk '{print $5}')"
echo

# Check external service connectivity
echo "=== External Service Connectivity ==="
echo -n "SQL Database Server (192.168.10.35): "
if ping -c 1 -W 2 192.168.10.35 > /dev/null 2>&1; then
    echo "✓ Connected"
else
    echo "✗ Not reachable"
fi

echo -n "Vector Database Server (192.168.10.30): "
if ping -c 1 -W 2 192.168.10.30 > /dev/null 2>&1; then
    echo "✓ Connected"
else
    echo "✗ Not reachable"
fi

echo -n "Metrics Server (192.168.10.37): "
if ping -c 1 -W 2 192.168.10.37 > /dev/null 2>&1; then
    echo "✓ Connected"
else
    echo "✗ Not reachable"
fi

echo -n "Web Server (192.168.10.38): "
if ping -c 1 -W 2 192.168.10.38 > /dev/null 2>&1; then
    echo "✓ Connected"
else
    echo "✗ Not reachable"
fi

echo

# Check project structure
echo "=== Project Structure ==="
if [ -d "$CITADEL_HOME" ]; then
    echo "✓ Project directory exists: $CITADEL_HOME"
    echo "✓ Directory size: $(du -sh $CITADEL_HOME | cut -f1)"
    echo "✓ Directory permissions: $(ls -ld $CITADEL_HOME | awk '{print $1, $3, $4}')"
else
    echo "✗ Project directory not found: $CITADEL_HOME"
fi

echo

# Check Python environment
echo "=== Python Environment ==="
source $CITADEL_HOME/bin/activate-citadel 2>/dev/null
if [ $? -eq 0 ]; then
    echo "✓ Python environment activated"
    echo "✓ Python version: $(python --version)"
    echo "✓ Installed packages: $(pip list | wc -l) packages"
else
    echo "✗ Failed to activate Python environment"
fi

echo
echo "=== Health Check Complete ==="
EOF

# Make health check script executable
chmod +x /opt/citadel/bin/citadel-health

# Test health check script
/opt/citadel/bin/citadel-health
# Expected: Comprehensive health check output with system status
```

### **Backup and Recovery Procedures**
Establish backup and recovery procedures for project data and configurations.

#### **Backup Script Creation**
```bash
# Create backup script
cat > /opt/citadel/bin/citadel-backup << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Backup Script

CITADEL_HOME="/opt/citadel"
BACKUP_DIR="/opt/citadel/backups"
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BACKUP_NAME="citadel_backup_${TIMESTAMP}"

# Create backup directory
mkdir -p $BACKUP_DIR

echo "=== Citadel AI Operating System - Backup Process ==="
echo "Timestamp: $(date)"
echo "Backup Name: $BACKUP_NAME"
echo

# Create backup archive
echo "Creating backup archive..."
tar -czf "$BACKUP_DIR/${BACKUP_NAME}.tar.gz" \
    --exclude="$CITADEL_HOME/env" \
    --exclude="$CITADEL_HOME/logs" \
    --exclude="$CITADEL_HOME/backups" \
    --exclude="$CITADEL_HOME/tmp" \
    -C /opt citadel

if [ $? -eq 0 ]; then
    echo "✓ Backup created successfully: $BACKUP_DIR/${BACKUP_NAME}.tar.gz"
    echo "✓ Backup size: $(du -sh $BACKUP_DIR/${BACKUP_NAME}.tar.gz | cut -f1)"
else
    echo "✗ Backup creation failed"
    exit 1
fi

# Create backup manifest
cat > "$BACKUP_DIR/${BACKUP_NAME}_manifest.txt" << MANIFEST
Citadel AI Operating System - Backup Manifest
==============================================
Backup Name: $BACKUP_NAME
Timestamp: $(date)
Server: hx-llm-server-01 (192.168.10.29)
Backup Size: $(du -sh $BACKUP_DIR/${BACKUP_NAME}.tar.gz | cut -f1)

Included Directories:
- /opt/citadel/architecture
- /opt/citadel/infrastructure
- /opt/citadel/frameworks
- /opt/citadel/operations
- /opt/citadel/config
- /opt/citadel/validation
- /opt/citadel/src
- /opt/citadel/bin
- /opt/citadel/documentation

Excluded Directories:
- /opt/citadel/env (Python virtual environment)
- /opt/citadel/logs (Log files)
- /opt/citadel/backups (Previous backups)
- /opt/citadel/tmp (Temporary files)

System Information:
- Python Version: $(python --version 2>/dev/null || echo "Not available")
- System Load: $(uptime | awk -F'load average:' '{print $2}')
- Disk Usage: $(df -h /opt/citadel | tail -1 | awk '{print $5}')
MANIFEST

echo "✓ Backup manifest created: $BACKUP_DIR/${BACKUP_NAME}_manifest.txt"

# Cleanup old backups (keep last 10)
echo "Cleaning up old backups..."
cd $BACKUP_DIR
ls -t citadel_backup_*.tar.gz | tail -n +11 | xargs -r rm
ls -t citadel_backup_*_manifest.txt | tail -n +11 | xargs -r rm
echo "✓ Old backups cleaned up (keeping last 10)"

echo
echo "=== Backup Process Complete ==="
EOF

# Make backup script executable
chmod +x /opt/citadel/bin/citadel-backup

# Create restore script
cat > /opt/citadel/bin/citadel-restore << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Restore Script

CITADEL_HOME="/opt/citadel"
BACKUP_DIR="/opt/citadel/backups"
BACKUP_FILE="$1"

if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: $0 <backup_file>"
    echo "Available backups:"
    ls -la $BACKUP_DIR/citadel_backup_*.tar.gz 2>/dev/null || echo "No backups found"
    exit 1
fi

if [ ! -f "$BACKUP_DIR/$BACKUP_FILE" ]; then
    echo "Error: Backup file not found: $BACKUP_DIR/$BACKUP_FILE"
    exit 1
fi

echo "=== Citadel AI Operating System - Restore Process ==="
echo "Timestamp: $(date)"
echo "Backup File: $BACKUP_FILE"
echo

# Confirm restore operation
read -p "This will overwrite existing configuration. Continue? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Restore cancelled"
    exit 0
fi

# Create temporary backup of current state
echo "Creating temporary backup of current state..."
TEMP_BACKUP="temp_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
tar -czf "$BACKUP_DIR/$TEMP_BACKUP" -C /opt citadel
echo "✓ Temporary backup created: $TEMP_BACKUP"

# Restore from backup
echo "Restoring from backup..."
cd /opt
tar -xzf "$BACKUP_DIR/$BACKUP_FILE"

if [ $? -eq 0 ]; then
    echo "✓ Restore completed successfully"
    
    # Restore Python environment
    echo "Recreating Python environment..."
    cd $CITADEL_HOME
    python3.12 -m venv env
    source env/bin/activate
    pip install -r requirements.txt
    echo "✓ Python environment restored"
    
    # Set proper permissions
    chown -R agent0:citadel $CITADEL_HOME
    chmod -R 755 $CITADEL_HOME
    chmod -R 700 $CITADEL_HOME/config/secrets
    echo "✓ Permissions restored"
    
else
    echo "✗ Restore failed"
    echo "Restoring from temporary backup..."
    tar -xzf "$BACKUP_DIR/$TEMP_BACKUP" -C /opt
    echo "✓ Reverted to previous state"
    exit 1
fi

echo
echo "=== Restore Process Complete ==="
EOF

# Make restore script executable
chmod +x /opt/citadel/bin/citadel-restore

# Test backup creation
/opt/citadel/bin/citadel-backup
# Expected: Successful backup creation with confirmation messages
```

---

## 📚 **USAGE PROCEDURES**

### **Daily Operations**
Standard procedures for daily project management and operations.

#### **Project Activation and Usage**
```bash
# Daily startup procedure
echo "=== Daily Citadel Startup Procedure ==="

# 1. Activate environment
source /opt/citadel/bin/activate-citadel

# 2. Check system health
/opt/citadel/bin/citadel-health

# 3. Review logs for any issues
tail -n 50 /opt/citadel/logs/citadel.log

# 4. Check external service connectivity
ping -c 1 192.168.10.35  # SQL Database
ping -c 1 192.168.10.30  # Vector Database
ping -c 1 192.168.10.37  # Metrics Server
ping -c 1 192.168.10.38  # Web Server

# 5. Verify firewall configuration (matching actual configuration)
sudo ufw status
# Expected: UFW enabled with ports 22, 8000-8100 allowed

# 6. Verify project structure integrity
ls -la /opt/citadel/

echo "✓ Daily startup checks complete"
```

#### **Development Workflow**
```bash
# Development session startup
echo "=== Development Session Startup ==="

# 1. Navigate to project directory
cd /opt/citadel

# 2. Activate environment
source bin/activate-citadel

# 3. Update from version control (when implemented)
# git pull origin main

# 4. Install any new dependencies
pip install -r requirements.txt

# 5. Run tests (when implemented)
# python -m pytest src/citadel_llm/testing/

# 6. Start development services (when implemented)
# ./bin/citadel-service start development

echo "✓ Development environment ready"
```

### **Configuration Management**
Procedures for managing configurations across different environments and MVP phases.

#### **Configuration Updates**
```bash
# Configuration update procedure
echo "=== Configuration Update Procedure ==="

# 1. Backup current configuration
cp -r /opt/citadel/config /opt/citadel/config_backup_$(date +%Y%m%d_%H%M%S)

# 2. Update configuration files
# Edit configuration files as needed
# nano /opt/citadel/config/global/citadel.yaml

# 3. Validate configuration syntax
python -c "
import yaml
import sys
try:
    with open('/opt/citadel/config/global/citadel.yaml', 'r') as f:
        yaml.safe_load(f)
    print('✓ Configuration syntax valid')
except Exception as e:
    print(f'✗ Configuration syntax error: {e}')
    sys.exit(1)
"

# 4. Test configuration with services (when implemented)
# ./bin/citadel-service restart all

# 5. Verify configuration changes
echo "✓ Configuration updated successfully"
```

#### **Environment-Specific Configuration**
```bash
# Environment configuration management
echo "=== Environment Configuration Management ==="

# Function to switch environments
switch_environment() {
    local env_name="$1"
    local config_file="/opt/citadel/config/environments/${env_name}/citadel.yaml"
    
    if [ -f "$config_file" ]; then
        cp "$config_file" /opt/citadel/config/global/citadel.yaml
        export CITADEL_ENV="$env_name"
        echo "✓ Switched to $env_name environment"
    else
        echo "✗ Environment configuration not found: $config_file"
        return 1
    fi
}

# Usage examples:
# switch_environment development
# switch_environment testing
# switch_environment staging
```

---

## 🔍 **TROUBLESHOOTING AND MAINTENANCE**

### **Common Issues and Solutions**
Documentation of common issues and their resolution procedures.

#### **Permission Issues**
```bash
# Fix permission issues
echo "=== Fixing Permission Issues ==="

# Reset ownership
sudo chown -R citadel:citadel /opt/citadel

# Reset permissions
sudo chmod -R 755 /opt/citadel
sudo chmod -R 700 /opt/citadel/config/secrets
sudo chmod -R 700 /opt/citadel/secrets
sudo chmod +x /opt/citadel/bin/*

# Verify permissions
ls -la /opt/citadel/
echo "✓ Permissions reset successfully"
```

#### **Environment Issues**
```bash
# Fix Python environment issues
echo "=== Fixing Python Environment Issues ==="

# Recreate virtual environment
cd /opt/citadel
rm -rf env
python3.12 -m venv env
source env/bin/activate

# Reinstall dependencies
pip install --upgrade pip setuptools wheel
pip install -r requirements.txt

# Verify environment
python --version
pip list
echo "✓ Python environment recreated successfully"
```

#### **Configuration Issues**
```bash
# Fix configuration issues
echo "=== Fixing Configuration Issues ==="

# Validate all configuration files
find /opt/citadel/config -name "*.yaml" -exec python -c "
import yaml
import sys
try:
    with open('{}', 'r') as f:
        yaml.safe_load(f)
    print('✓ {}')
except Exception as e:
    print('✗ {}: {}'.format('{}', e))
" \;

# Reset to default configuration if needed
# cp /opt/citadel/config/templates/* /opt/citadel/config/global/

echo "✓ Configuration validation complete"
```

### **Maintenance Procedures**
Regular maintenance tasks to ensure optimal system performance.

#### **Weekly Maintenance**
```bash
# Weekly maintenance script
cat > /opt/citadel/bin/citadel-maintenance << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Weekly Maintenance Script

echo "=== Citadel Weekly Maintenance ==="
echo "Timestamp: $(date)"
echo

# 1. Create backup
echo "Creating weekly backup..."
/opt/citadel/bin/citadel-backup

# 2. Clean up logs
echo "Cleaning up old logs..."
find /opt/citadel/logs -name "*.log.*" -mtime +30 -delete
echo "✓ Old logs cleaned up"

# 3. Update system packages
echo "Checking for system updates..."
sudo apt update
sudo apt list --upgradable

# 4. Check disk usage
echo "Checking disk usage..."
df -h /opt/citadel
du -sh /opt/citadel/*

# 5. Verify external service connectivity
echo "Verifying external service connectivity..."
/opt/citadel/bin/citadel-health | grep -A 10 "External Service Connectivity"

# 6. Performance check
echo "Performance check..."
echo "CPU Usage: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)%"
echo "Memory Usage: $(free | grep Mem | awk '{printf "%.1f%%", $3/$2 * 100.0}')"
echo "Load Average: $(uptime | awk -F'load average:' '{print $2}')"

echo
echo "=== Weekly Maintenance Complete ==="
EOF

chmod +x /opt/citadel/bin/citadel-maintenance

# Test maintenance script
/opt/citadel/bin/citadel-maintenance
# Expected: Comprehensive maintenance report with system status
```

---

## 📋 **VALIDATION AND TESTING**

### **Setup Validation**
Comprehensive validation procedures to ensure proper project structure setup.

#### **Complete Setup Validation Script**
```bash
# Create comprehensive validation script
cat > /opt/citadel/bin/citadel-validate-setup << 'EOF'
#!/bin/bash
# Citadel AI Operating System - Setup Validation Script

echo "=== Citadel AI Operating System - Setup Validation ==="
echo "Timestamp: $(date)"
echo "Server: hx-llm-server-01 (192.168.10.27)"
echo

VALIDATION_PASSED=true

# Function to check and report
check_item() {
    local description="$1"
    local command="$2"
    
    echo -n "Checking $description... "
    if eval "$command" > /dev/null 2>&1; then
        echo "✓ PASS"
    else
        echo "✗ FAIL"
        VALIDATION_PASSED=false
    fi
}

# Hardware validation
echo "=== Hardware Validation ==="
check_item "CPU architecture" "lscpu | grep -q 'AMD Ryzen Threadripper PRO 7965WX'"
check_item "Memory capacity" "[ \$(free -g | grep Mem | awk '{print \$2}') -ge 256 ]"
check_item "NVMe storage mounted" "mount | grep -q nvme0n1"
check_item "Archive storage mounted" "mount | grep -q sda"
check_item "GPU availability" "nvidia-smi > /dev/null 2>&1"
check_item "Dual GPU configuration" "[ \$(nvidia-smi --list-gpus | wc -l) -eq 2 ]"
echo

# Directory structure validation
echo "=== Directory Structure Validation ==="
check_item "Base directory exists" "[ -d /opt/citadel ]"
check_item "Architecture directory" "[ -d /opt/citadel/architecture ]"
check_item "Infrastructure directory" "[ -d /opt/citadel/infrastructure ]"
check_item "Frameworks directory" "[ -d /opt/citadel/frameworks ]"
check_item "Operations directory" "[ -d /opt/citadel/operations ]"
check_item "Config directory" "[ -d /opt/citadel/config ]"
check_item "Validation directory" "[ -d /opt/citadel/validation ]"
check_item "Source directory" "[ -d /opt/citadel/src ]"
check_item "Bin directory" "[ -d /opt/citadel/bin ]"
check_item "Logs directory" "[ -d /opt/citadel/logs ]"
check_item "Model storage directory" "[ -d /mnt/nvme0n1/models ]"
check_item "Archive logs directory" "[ -d /mnt/sda/logs/llm ]"
echo

# Permissions validation
echo "=== Permissions Validation ==="
check_item "Base directory ownership" "[ \$(stat -c '%U:%G' /opt/citadel) = 'citadel:citadel' ]"
check_item "Config directory permissions" "[ \$(stat -c '%a' /opt/citadel/config) = '755' ]"
check_item "Secrets directory permissions" "[ \$(stat -c '%a' /opt/citadel/config/secrets) = '700' ]"
check_item "Main secrets directory permissions" "[ \$(stat -c '%a' /opt/citadel/secrets) = '700' ]"
check_item "Bin scripts executable" "[ -x /opt/citadel/bin/activate-citadel ]"
echo

# Configuration validation
echo "=== Configuration Validation ==="
check_item "Global configuration exists" "[ -f /opt/citadel/config/global/citadel.yaml ]"
check_item "Logging configuration exists" "[ -f /opt/citadel/config/global/logging.yaml ]"
check_item "Metrics configuration exists" "[ -f /opt/citadel/config/global/metrics.yaml ]"
check_item "Configuration syntax valid" "python -c 'import yaml; yaml.safe_load(open(\"/opt/citadel/config/global/citadel.yaml\"))'"
echo

# Python environment validation
echo "=== Python Environment Validation ==="
check_item "Python virtual environment exists" "[ -d /opt/citadel/env ]"
check_item "Python 3.12 available" "python3.12 --version"
check_item "Requirements file exists" "[ -f /opt/citadel/requirements.txt ]"
check_item "Virtual environment activates" "source /opt/citadel/env/bin/activate && python --version"
check_item "vLLM package installed" "source /opt/citadel/env/bin/activate && python -c 'import vllm'"
check_item "PyTorch CUDA support" "source /opt/citadel/env/bin/activate && python -c 'import torch; print(torch.cuda.is_available())'"
echo

# Service framework validation
echo "=== Service Framework Validation ==="
check_item "Base service template exists" "[ -f /opt/citadel/src/citadel_llm/services/base_service.py ]"
check_item "vLLM service template exists" "[ -f /opt/citadel/src/citadel_llm/services/vllm_service.py ]"
check_item "API Gateway exists" "[ -f /opt/citadel/src/citadel_llm/api_gateway/main.py ]"
check_item "Logging utility exists" "[ -f /opt/citadel/src/citadel_llm/utilities/logging_config.py ]"
check_item "Metrics utility exists" "[ -f /opt/citadel/src/citadel_llm/utilities/metrics_collector.py ]"
check_item "Service framework imports" "cd /opt/citadel && python -c 'import sys; sys.path.append(\"src\"); from citadel_llm.services.base_service import BaseService'"
check_item "vLLM service imports" "cd /opt/citadel && python -c 'import sys; sys.path.append(\"src\"); from citadel_llm.services.vllm_service import VLLMService'"
check_item "API Gateway imports" "cd /opt/citadel && python -c 'import sys; sys.path.append(\"src/citadel_llm/api_gateway\"); from main import app'"
echo

# External connectivity validation
echo "=== External Connectivity Validation ==="
check_item "SQL Database Server connectivity" "ping -c 1 -W 2 192.168.10.35"
check_item "Vector Database Server connectivity" "ping -c 1 -W 2 192.168.10.30"
check_item "Metrics Server connectivity" "ping -c 1 -W 2 192.168.10.37"
check_item "Web Server connectivity" "ping -c 1 -W 2 192.168.10.38"
check_item "Hostname configuration" "[ \$(hostname) = 'hx-llm-server-01' ]"
check_item "Network IP configuration" "[ \$(hostname -I | grep -o '192.168.10.27') = '192.168.10.27' ]"
check_item "Firewall configuration" "sudo ufw status | grep -q 'Status: active'"
echo

# Operational scripts validation
echo "=== Operational Scripts Validation ==="
check_item "Environment activation script" "[ -x /opt/citadel/bin/activate-citadel ]"
check_item "Service management script" "[ -x /opt/citadel/bin/citadel-service ]"
check_item "Systemd management script" "[ -x /opt/citadel/bin/citadel-systemd ]"
check_item "Monitoring startup script" "[ -x /opt/citadel/bin/start-monitoring ]"
check_item "GPU monitoring script" "[ -x /opt/citadel/bin/gpu_monitor.sh ]"
check_item "vLLM startup script" "[ -x /opt/citadel/bin/start_vllm.sh ]"
check_item "Health check script" "[ -x /opt/citadel/bin/citadel-health ]"
check_item "Backup script" "[ -x /opt/citadel/bin/citadel-backup ]"
check_item "Restore script" "[ -x /opt/citadel/bin/citadel-restore ]"
check_item "Maintenance script" "[ -x /opt/citadel/bin/citadel-maintenance ]"
echo

# Final validation result
echo "=== Validation Summary ==="
if [ "$VALIDATION_PASSED" = true ]; then
    echo "✓ ALL VALIDATIONS PASSED"
    echo "✓ Project structure setup is complete and ready for use"
    echo "✓ Server configuration matches actual hardware specifications"
    echo "✓ You can now proceed with MVP implementation"
    exit 0
else
    echo "✗ SOME VALIDATIONS FAILED"
    echo "✗ Please review and fix the failed items before proceeding"
    echo "✗ Run this validation script again after fixes"
    exit 1
fi
EOF

chmod +x /opt/citadel/bin/citadel-validate-setup

# Run complete validation
/opt/citadel/bin/citadel-validate-setup
# Expected: Comprehensive validation report with all checks passing
```

---

## 📖 **DOCUMENTATION AND NEXT STEPS**

### **Project Structure Documentation**
The project structure is now established and ready for MVP implementation. The following components are operational:

#### **Established Infrastructure**
- **Base Directory Structure:** Complete `/opt/citadel/` hierarchy with proper permissions
- **Configuration Management:** Global, service-specific, and environment-specific configurations
- **Python Environment:** Python 3.12 virtual environment with vLLM and AI model dependencies
- **Service Framework:** Base service templates, vLLM service templates, and utilities for AI model implementation
- **FastAPI API Gateway:** Basic API gateway with OpenAI-compatible endpoints and health monitoring
- **Systemd Integration:** Complete systemd service templates and management scripts
- **Enhanced Monitoring:** Prometheus integration with external metrics server and alerting
- **Operational Scripts:** Complete set of management, backup, maintenance, and monitoring scripts

#### **External Service Integration**
- **SQL Database Server (192.168.10.35):** Connectivity validated and ready for integration
- **Vector Database Server (192.168.10.30):** Connectivity validated and ready for integration
- **Metrics Server (192.168.10.37):** Connectivity validated and ready for metrics collection
- **Web Server (192.168.10.38):** Connectivity validated and ready for OpenUI integration

### **Next Steps for MVP Implementation**
With the project structure established, the following steps should be taken to proceed with MVP implementation:

#### **Immediate Actions**
1. **Run Final Validation:** Execute `/opt/citadel/bin/citadel-validate-setup` to confirm all components are properly configured
2. **Create Initial Backup:** Run `/opt/citadel/bin/citadel-backup` to create a baseline backup
3. **Document Current State:** Record the current configuration and setup for future reference
4. **Team Onboarding:** Provide team members with access and training on the project structure

#### **MVP 1 Preparation**
1. **AI Model Files:** Obtain and prepare the four AI model files (Mixtral-8x7B, Hermes-2, OpenChat-3.5, Phi-3-Mini)
2. **Service Implementation:** Begin implementing AI model services using the established service framework
3. **API Gateway Development:** Develop the unified API gateway for model access
4. **Integration Testing:** Test connectivity and integration with external services

#### **Ongoing Operations**
1. **Daily Health Checks:** Use `/opt/citadel/bin/citadel-health` for daily system monitoring
2. **Weekly Maintenance:** Schedule `/opt/citadel/bin/citadel-maintenance` for regular maintenance
3. **Configuration Management:** Use established procedures for configuration updates and environment management
4. **Backup and Recovery:** Maintain regular backups and test recovery procedures

---

## 📞 **SUPPORT AND TROUBLESHOOTING**

### **Common Commands Reference**
```bash
# Environment activation
source /opt/citadel/bin/activate-citadel

# System health check
/opt/citadel/bin/citadel-health

# Service management (when services are implemented)
/opt/citadel/bin/citadel-service {start|stop|restart|status|health} <service_name>

# Systemd service management
/opt/citadel/bin/citadel-systemd {install|start|stop|restart|status|logs} [service_name]

# Monitoring management
/opt/citadel/bin/start-monitoring

# Backup and restore
/opt/citadel/bin/citadel-backup
/opt/citadel/bin/citadel-restore <backup_file>

# Maintenance
/opt/citadel/bin/citadel-maintenance

# Setup validation
/opt/citadel/bin/citadel-validate-setup
```

### **Emergency Procedures**
In case of critical issues, follow these emergency procedures:

1. **System Recovery:** Use backup and restore procedures to recover from critical failures
2. **Service Isolation:** Stop problematic services to prevent system-wide issues
3. **External Service Fallback:** Implement fallback procedures for external service failures
4. **Escalation:** Contact system administrators for infrastructure-level issues

### **Contact Information**
- **Infrastructure Team:** For server and network issues
- **Development Team:** For application and service issues
- **Operations Team:** For ongoing maintenance and monitoring
- **Security Team:** For security-related concerns

---

**🎯 This comprehensive setup and usage guide provides everything needed to establish and operate the HXP-Enterprise LLM Server project structure on the target server, ensuring consistent deployment and management across all MVP phases!**

